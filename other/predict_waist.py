# -*- coding: utf-8 -*-
"""predict_waist.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AF6QvcOuFAHmqEW5XrFDZyOhgwew1UMo
"""

# include whatever other imports you need here
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import TensorDataset, DataLoader
from sklearn.metrics import r2_score
import matplotlib.pyplot as plt
from torch.optim.lr_scheduler import StepLR
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error
import joblib
# Your network definition goes here
class WaistPredictionNetwork(nn.Module):
  def __init__(self, hiddenSize, hiddenSize2, hiddenSize3, hiddenSize4):
    super(WaistPredictionNetwork, self).__init__()
    self.linear1 = nn.Linear(5, hiddenSize)
    self.linear2 = nn.Linear(hiddenSize, hiddenSize2)
    self.linear3 = nn.Linear(hiddenSize2, hiddenSize3)
    self.linear4 = nn.Linear(hiddenSize3, hiddenSize4)
    self.linear5 = nn.Linear(hiddenSize4, 1)
    self.relu = nn.ReLU()


  def forward(self, x):
    y = self.relu(self.linear1(x))
    y = self.relu(self.linear2(y))
    y = self.relu(self.linear3(y))
    y = self.relu(self.linear4(y))
    y = self.linear5(y)
    return y

def predict(measurements):
   # Determine which device the input tensor is on
   device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
   print("Using device: ", device)
   model = WaistPredictionNetwork(16, 32, 32, 16) # Add your model init parameters here if you have any
   # Move to same device as input
   model = model.to(device)
   # Load network weights
   # ---------------- Please import 'q4_weights.pkl' to local google colab session ----------------
   model.load_state_dict(torch.load('q4_weights.pkl',map_location=torch.device(device)))
   # Put model in evaluation mode
   model.eval()

   # Optional: do whatever preprocessing you do on the inputs
   # ---------------- Please import 'y_scaler_q4.pkl' to local google colab session ----------------
   x_scaler_q4 = joblib.load('q4_x_scaler.pkl')
   measurements = measurements.numpy()
   measurements = x_scaler_q4.transform(measurements)
   measurements = torch.tensor(measurements, dtype=torch.float32)
   measurements = measurements.to(device)
   # if not included as tranformations inside the model

   with torch.no_grad():
       # Pass inputs to model
       predicted_waists = model(measurements)

   # If your output needs any post-processing, do it here
   # ---------------- Please import 'y_scaler_q4.pkl' to local google colab session ----------------
   y_scaler_q4 = joblib.load('q4_y_scaler.pkl')
   predicted_waists = predicted_waists.detach().cpu().numpy()
   predicted_waists = y_scaler_q4.inverse_transform(predicted_waists)
   # turn back into tensor onto gpu
   predicted_waists = torch.tensor(predicted_waists, dtype=torch.float32)

   # Return predicted waist measurements (result is tensor on cpu)
   return predicted_waists

# Test to see if single example tensor works
'''
measurement = torch.tensor(np.array([0,904,1000,1723,60.9]), dtype=torch.float32).reshape(1,-1)
print(predict(measurement))
'''