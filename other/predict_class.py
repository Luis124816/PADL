# -*- coding: utf-8 -*-
"""predict_class.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FQZ883NzFGex_Jlhvow73VDZzRwnkBvb
"""

# include whatever other imports you need here
import os
import shutil
import pandas as pd
from PIL import Image
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.utils.data import Dataset, DataLoader, random_split
import torch.optim as optim
import torchvision.transforms as transforms
import torchvision.transforms.functional as TF

# Your network definition goes here
class CNN(nn.Module):
    def __init__(self):
        super(CNN, self).__init__()

        self.convolutions = nn.Sequential(
            nn.Conv2d(1, 32, kernel_size=3, padding=1),
            nn.BatchNorm2d(32),
            nn.ReLU(),
            nn.MaxPool2d(2),

            nn.Conv2d(32, 64, kernel_size=3, padding=1),
            nn.BatchNorm2d(64),
            nn.ReLU(),
            nn.MaxPool2d(2),

            nn.Conv2d(64, 128, kernel_size=3, padding=1),
            nn.BatchNorm2d(128),
            nn.ReLU(),
            nn.MaxPool2d(2),

            nn.Conv2d(128, 256, kernel_size=3, padding=1),
            nn.BatchNorm2d(256),
            nn.ReLU(),
            nn.MaxPool2d(2),
        )

        self.mlp = nn.Sequential(
            nn.Flatten(),
            nn.Linear(256 * 10 * 10, 128),
            nn.ReLU(),
            nn.Dropout(0.5),
            nn.Linear(128, 3)
        )

    def forward(self, x):
        x = self.convolutions(x)
        x = self.mlp(x)
        return x






def predict(images):
   # Determine which device the input tensor is on
   device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
   print("Using device: ", device)
   model = CNN() # Add your model init parameters here if you have any
   # Move to same device as input
   model = model.to(device)
   # Load network weights
   # ---------------- Please import 'q5_weights.pkl' to local google colab session ----------------
   model.load_state_dict(torch.load('q5_weights.pkl',map_location=torch.device(device)))
   # Put model in evaluation mode
   model.eval()

   # Optional: do whatever preprocessing you do on the inputs
   images = images.unsqueeze(0).to(device)
   images = TF.rgb_to_grayscale(images, num_output_channels=1)
   images = F.interpolate(images, size=(160, 160), mode='bilinear', align_corners=False)
   # if not included as tranformations inside the model


   # If your output needs any post-processing, do it here
   model.eval()
   with torch.no_grad():
    outputs = model(images)
    probability_distribution = F.softmax(outputs, dim=1)
    print(probability_distribution)
    predicted = torch.argmax(probability_distribution, dim=1).cpu().numpy()
   # return predictions on the cpu
   return predicted